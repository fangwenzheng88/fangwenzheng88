# Docker的三大核心组件：镜像，容器与仓库

镜像（docker image）就是一个打包好的安装文件，镜像中不仅包含你的应用，还包含应用运行需要的所有依赖和环境，上至一些library，下至操作系统。而容器（docker container）就是我们在docker Engine环境中启动的镜像实例，容器和操作系统中其它进程没有区别，只不过拥有自己的网络和存储，与系统中其它的进程实现隔离，同时也与其它容器隔离。

## 一、镜像(Image)

什么是`Docker`镜像？

简单地理解，`Docker`镜像就是一个`Linux`的文件系统(`Root FileSystem`)，这个文件系统里面包含可以运行在`Linux`内核的程序以及相应的数据。

操作系统相关的知识：
> 一般而言， `Linux`分为两个部分：`Linux`内核(`Linux Kernel`)与用户空间，而真正的`Linux`操作系统，是指`Linux`内核，我们常用的`Ubuntu`,`Centos`等操作系统其实是不同厂商在`Linux`内核基础上添加自己的软件与工具集(`tools`)形成的发布版本(`Linux Distribution`)。

因此，我们也可以把镜像看成是上面所说的用户空间，当`Docker`通过镜像创建一个容器时，就是将镜像定义好的用户空间作为独立隔离的进程运行在宿主机的`Linux`内核之上。
这里要强调一下镜像的两个特征：


镜像是分层(`Layer`)的：即一个镜像可以多个中间层组成，多个镜像可以共享同一中间层，我们也可以通过在镜像添加多一层来生成一个新的镜像。


镜像是只读的(`read-only`)：镜像在构建完成之后，便不可以再修改，而上面我们所说的添加一层构建新的镜像，这中间实际是通过创建一个临时的容器，在容器上增加或删除文件，从而形成新的镜像，因为容器是可以动态改变的。


通过下面的示意图，我可以更好地理解`Docker`镜像与`Linux`的关系：

![](http://fang.images.fangwenzheng.top/20200414150645.png)

## 二、容器(Container)

容器与镜像的关系，就如同面向编程中对象与类之间的关系。

因为容器是通过镜像来创建的，所以必须先有镜像才能创建容器，而生成的容器是一个独立于宿主机的隔离进程，并且有属于容器自己的网络和命名空间。

我们前面介绍过，镜像由多个中间层(layer)组成，生成的镜像是只读的，但容器却是可读可写的，这是因为容器是在镜像上面添一层读写层(writer/read layer)来实现的，如下图所示：

![](http://fang.images.fangwenzheng.top/20200414150616.png)

## 三、仓库(Repository)

仓库(Repository)是集中存储镜像的地方，这里有个概念要区分一下，那就是仓库与仓库服务器(Registry)是两回事，像我们上面说的Docker Hub，就是Docker官方提供的一个仓库服务器，不过其实有时候我们不太需要太过区分这两个概念。

不过要将镜像上传到Docker Hub，必须先在Docker的官方网站上注册一个账号，注册界面如下，按要求填写必要的信息就可以注册了，很简单的。